#!/usr/bin/env python3

import os, sys, subprocess
# these are for testing to generate a random hal name
import random, string

# disable cache usage must be before any local imports
sys.dont_write_bytecode = True

from functools import partial

from PyQt6.QtWidgets import QApplication, QMainWindow
from PyQt6.uic import loadUi
from PyQt6.QtCore import Qt, QTimer, QEvent, QSettings

import linuxcnc, hal

from libflexgui import startup
from libflexgui import status
from libflexgui import dialogs

class flexgui(QMainWindow):
	def __init__(self):
		super().__init__()

		self.settings = QSettings('JET', 'Flex GUI')

		# get the path to the executable
		self.path = os.path.dirname(os.path.realpath(sys.argv[0]))

		# set the library path FIXME get examples path
		if self.path == '/usr/bin':
			self.lib_path = '/usr/lib/libflexgui'
			self.gui_path = '/usr/lib/libflexgui'
			self.examples_path = '/usr/lib/libflexgui/examples'
		else:
			self.lib_path = os.path.join(self.path, 'libflexgui')
			self.gui_path = self.path
			root_path = os.path.abspath(os.path.join(os.getcwd() ,"../.."))
			self.examples_path = os.path.join(root_path, 'examples')

		startup.copy_examples(self)

		# check to see if linuxcnc is running
		cp = subprocess.run(['pgrep', '-l', 'linuxcnc'], text=True, capture_output=True)
		if 'linuxcnc' not in cp.stdout:
			#configs_dir = os.path.join(os.path.expanduser('~'), 'linuxcnc', 'configs', 'flex_examples')
			#if os.path.isdir(configs_dir):
			msg = ('Flex GUI can not run without LinuxCNC.\n'
			'A LinuxCNC Simulator can be started first\n'
			'to start Flex GUI for TESTING ONLY!')
			dialogs.warn_msg_ok(msg, 'Error')
			sys.exit()

			response = startup.copy_examples(self, 'LinuxCNC not running')
			if response:
				sys.exit()


		# connect to linuxcnc
		self.status = linuxcnc.stat()
		self.status.poll()
		# initalize exec_state and task_state which is checked in status.py
		self.exec_state = self.status.exec_state
		self.task_state = self.status.task_state
		self.task_mode = self.status.task_mode
		self.interp_state = self.status.interp_state
		self.motion_mode = self.status.motion_mode
		self.state = self.status.state
		self.command = linuxcnc.command()
		self.error = linuxcnc.error_channel()
		# setup a hal component using a random name for testing
		self.halcomp = hal.component(''.join(random.choices(string.ascii_letters + string.digits, k=5)))

		# get connection to the ini file
		self.inifile = False
		for i in range(len(sys.argv)): # check if running from ini DISPLAY entry
			if sys.argv[i].endswith('.ini'):
				self.inifile = linuxcnc.ini(sys.argv[i])
				self.ini_path = os.path.split(sys.argv[i])[0]
				break
		if not self.inifile: # otherwise it's running with axis for testing
			self.inifile = linuxcnc.ini(self.status.ini_filename)
			self.ini_path = os.path.split(self.status.ini_filename)[0]

		# get ini values if any
		gui = self.inifile.find('DISPLAY', 'DISPLAY') or False
		gui_file = self.inifile.find('DISPLAY', 'GUI') or False
		input_type = self.inifile.find('DISPLAY', 'INPUT') or False
		qss_file = self.inifile.find('DISPLAY', 'QSS') or False
		screen_size = self.inifile.find('DISPLAY', 'SIZE') or False

		# find and load the gui
		if gui_file: # gui is in the ini file
			gui_path = os.path.join(os.path.dirname(self.status.ini_filename), gui_file)
			if not os.path.isfile(gui_path): # gui not found
				#print(f'The {gui_path} was not found')
				gui_path = os.path.join(self.gui_path, 'flex.ui')
				gui_file = 'flex.ui'
		else: # no gui specified
			gui_path = os.path.join(self.gui_path, 'flex.ui')
			gui_file = 'flex.ui'

		results = subprocess.run(['dpkg-query', '-W', 'flexgui'], text=True, capture_output=True)
		if results.stdout:
			flex_version = results.stdout.split()[1]
		else:
			flex_version = 'Unknown'

		loadUi(gui_path, self)
		self.setWindowTitle(f'Flex GUI - Version: {flex_version} - Using {gui_file}')

		# find and load the stylesheet
		stylesheet = False
		if input_type:
			if input_type.lower() == 'touch':
				stylesheet = os.path.join(self.lib_path, 'touch.qss')
			elif input_type.lower() == 'keyboard':
				stylesheet = os.path.join(self.lib_path, 'keyboard.qss')

		if qss_file: # load local qss file make sure it exists !!!!!
			if os.path.isfile(os.path.join(self.ini_path, qss_file)):
				stylesheet = os.path.join(self.ini_path, qss_file)

		if stylesheet:
			with open(stylesheet, 'r') as f:
				self.setStyleSheet(f.read())

		startup.setup_recent_files(self)
		startup.find_children(self)
		startup.get_ini_values(self)
		startup.setup_enables(self)
		startup.setup_buttons(self)
		startup.setup_actions(self)
		startup.setup_status_labels(self)
		startup.setup_plain_text_edits(self)
		startup.setup_check_boxes(self)
		startup.setup_spindle(self)
		startup.setup_jog(self)
		startup.setup_mdi(self)
		# loading the post gui files can only happen once
		if gui.lower() == 'flexgui':
			startup.load_postgui(self)
		startup.setup_tool_change(self)
		startup.setup_sliders(self)
		startup.setup_defaults(self)
		startup.setup_plot(self)
		#startup.setup_hal_buttons(self)

		# setup and start the status update timer every 0.01 second
		self.timer = QTimer()
		self.timer.timeout.connect(partial(status.update, self))
		self.timer.start(10) # milliseconds

		# set the inital screen size
		if screen_size:
			if screen_size.lower() == 'minimized':
				self.showMinimized()
			if screen_size.lower() == 'normal':
				self.showNormal()
			if screen_size.lower() == 'maximized':
				self.showMaximized()
			elif screen_size.lower() == 'full':
				self.showFullScreen()
		else:
			self.show()


app = QApplication(sys.argv)
gui = flexgui()
sys.exit(app.exec())
